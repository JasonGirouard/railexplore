# -*- coding: utf-8 -*-
"""Routing from point A to Be, Claude Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BNWaOIkeyZbwskRsFbawEYAcbl62UWGG
"""
import sys
import pandas as pd
import numpy as np
from pandas import json_normalize
import duckdb
import json
import networkx as nx
from datetime import datetime, timedelta
from datetime import timezone
from collections import defaultdict
import heapq
import time
from queue import PriorityQueue
import requests

url = "https://mgwalker.github.io/amtrak-api/trains.json"
try:
    response = requests.get(url)
    response.raise_for_status()  # Raise an exception for unsuccessful requests
    data = response.json()
except requests.exceptions.RequestException as e:
    print("Error occurred while fetching the JSON data:", e)

# Write the JSON data to a file named trains_data.json
#with open('trains_data.json', 'w') as file:
  #json.dump(data, file, indent=4)

#print("JSON data has been written to trains_data.json")



# Extract the relevant information from the JSON
train_data = []
for train in data:
    train_number = train['number']
    train_route = train['route']
    stations = train['stations']

    for i, station in enumerate(stations):
        station_code = station['station']['code']
        station_name = station['station']['name']
        station_lat = station['station']['lat']
        station_lon = station['station']['lon']

        arrival_actual = station.get('arrivalActual')
        arrival_estimated = station.get('arrivalEstimated')
        arrival_scheduled = station.get('arrivalScheduled')

        departure_actual = station.get('departureActual')
        departure_estimated = station.get('departureEstimated')
        departure_scheduled = station.get('departureScheduled')

        # Prioritize Scheduled time over Estimated and Actual time for Arrival
        arrival_time = arrival_scheduled
        arrival_method = 'scheduled'

        if arrival_time is None:
            arrival_time = arrival_estimated
            arrival_method = 'estimated'

        if arrival_time is None:
            arrival_time = arrival_actual
            arrival_method = 'actual'

        # Choose the Departure time based on the same method as Arrival
        if arrival_method == 'scheduled':
            departure_time = departure_scheduled
        elif arrival_method == 'estimated':
            departure_time = departure_estimated
        else:
            departure_time = departure_actual

        # Handle cases where all arrival times are None for the first stop
        if i == 0 and arrival_time is None:
            arrival_time = departure_time

        # Handle cases where all departure times are None for the last stop
        if i == len(stations) - 1 and departure_time is None:
            departure_time = arrival_time

        # If departure time is still None, set it equal to the arrival time
        if departure_time is None:
            departure_time = arrival_time

        # Check if departure is after arrival
        is_departure_after_arrival = pd.to_datetime(departure_time) >= pd.to_datetime(arrival_time) if arrival_time and departure_time else False

        # Get the next station code and name if it exists
        next_station = stations[i + 1]['station']['code'] if i < len(stations) - 1 else None
        next_station_name = stations[i + 1]['station']['name'] if i < len(stations) - 1 else None

        # Calculate the travel time to the next station
        if next_station:
            next_arrival_time = pd.to_datetime(stations[i + 1]['arrivalScheduled'])
            if pd.isnull(next_arrival_time):
                next_arrival_time = pd.to_datetime(stations[i + 1]['arrivalEstimated'])
            if pd.isnull(next_arrival_time):
                next_arrival_time = pd.to_datetime(stations[i + 1]['arrivalActual'])
            travel_time = next_arrival_time - pd.to_datetime(departure_time) if departure_time and next_arrival_time else None
        else:
            travel_time = None

        train_data.append([
            train_number,
            train_route, station_code, station_name, train_route, next_station, next_station_name, travel_time, arrival_time, departure_time,
            # departure_actual, departure_estimated, departure_scheduled,
            # arrival_actual, arrival_estimated, arrival_scheduled
        ])
# Create the DataFrame with all columns, including commented out columns
df = pd.DataFrame(train_data, columns=[
    'train_number',
    'from_route', 'from_station', 'from_station_name', 'to_route', 'to_station', 'to_station_name', 'time', 'arrival', 'departure',
    # 'departureActual', 'departureEstimated', 'departureScheduled',
    # 'arrivalActual', 'arrivalEstimated', 'arrivalScheduled'
])

# Convert 'time' column to seconds and change its data type to integer
df['time'] = df['time'].dt.total_seconds().fillna(0).astype(int)
# Cast 'arrival' and 'departure' columns to datetime
df['arrival'] = pd.to_datetime(df['arrival'])
df['departure'] = pd.to_datetime(df['departure'])
# Convert all other columns (excluding 'time', 'arrival', 'departure') to string
string_columns = df.columns.drop(['time', 'arrival', 'departure'])
df[string_columns] = df[string_columns].astype(str)
# Replace None values with empty strings in string columns
df[string_columns] = df[string_columns].fillna('')

#function to calculate point a to point b is below

def calculate_elapsed_time(start_time, end_time):
    elapsed_time = end_time - start_time
    return elapsed_time

def dijkstra(df, origin_station, destination_station):
    # Create a dictionary to store the graph
    graph = {}
    for _, row in df.iterrows():
        from_station = row['from_station']
        to_station = row['to_station']
        route_name = row['from_route']
        train_number = row['train_number']
        departure_time = pd.to_datetime(row['departure'])
        arrival_time = pd.to_datetime(row['arrival'])

        if from_station not in graph:
            graph[from_station] = []
        graph[from_station].append((to_station, route_name, train_number, departure_time, arrival_time))

    # Initialize variables
    paths = []
    visited = set()
    pq = [(0, origin_station, [], None, None, None, None)]

    while pq:
        (cost, current_station, path, route_names, train_numbers, departure_times, arrival_times) = heapq.heappop(pq)

        if (current_station, arrival_times[-1] if arrival_times else None) in visited:
            continue

        visited.add((current_station, arrival_times[-1] if arrival_times else None))
        path = path + [current_station]

        if current_station == destination_station:
            path_info = {
                'route_names': list(set(route_names)),
                'start_time': departure_times[0].isoformat(),
                'end_time': arrival_times[-1].isoformat(),
                'elapsed_time': str(calculate_elapsed_time(departure_times[0], arrival_times[-1])),
                'transfers': [],
                'stops': []
            }
            for i in range(len(path) - 1):
                stop_info = {
                    'station': path[i],
                    'route_name': route_names[i],
                    'train_number': train_numbers[i],
                    'arrival_time': arrival_times[i].isoformat(),
                    'departure_time': departure_times[i].isoformat(),
                    'next_stop': path[i+1]
                }
                path_info['stops'].append(stop_info)

                if i < len(route_names) - 1 and route_names[i] != route_names[i+1]:
                    path_info['transfers'].append({
                        'station': path[i+1],
                        'arrival_time': arrival_times[i].isoformat(),
                        'departure_time': departure_times[i+1].isoformat(),
                        'layover_time': str(calculate_elapsed_time(arrival_times[i], departure_times[i+1]))
                    })

            # Add the last stop
            path_info['stops'].append({
                'station': path[-1],
                'route_name': route_names[-1],
                'train_number': train_numbers[-1],
                'arrival_time': arrival_times[-1].isoformat(),
                'departure_time': departure_times[-1].isoformat(),
                'next_stop': None
            })

            paths.append(path_info)
            continue  # Move to the next path in the priority queue

        if current_station in graph:
            for neighbor, route_name, train_number, departure_time, arrival_time in graph[current_station]:
                if arrival_times is None or departure_time >= arrival_times[-1]:
                    new_route_names = route_names + [route_name] if route_names else [route_name]
                    new_train_numbers = train_numbers + [train_number] if train_numbers else [train_number]
                    new_departure_times = departure_times + [departure_time] if departure_times else [departure_time]
                    new_arrival_times = arrival_times + [arrival_time] if arrival_times else [arrival_time]
                    heapq.heappush(pq, (cost + 1, neighbor, path, new_route_names, new_train_numbers, new_departure_times, new_arrival_times))

    # Filter paths to keep only the shortest elapsed time for each start time
    filtered_paths = []
    start_time_dict = {}
    for path in paths:
        start_time = path['start_time']
        elapsed_time = pd.Timedelta(path['elapsed_time'])

        if start_time not in start_time_dict or elapsed_time < start_time_dict[start_time]['elapsed_time']:
            start_time_dict[start_time] = {
                'elapsed_time': elapsed_time,
                'path': path
            }

    filtered_paths = [path_info['path'] for path_info in start_time_dict.values()]

    return json.dumps(filtered_paths, default=str)

# Example usage
#origin_station = 'NYP'
#destination_station = 'DET'
#paths_json = dijkstra(df, origin_station, destination_station)
#print(paths_json)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: python path_calculation.py <origin_station> <destination_station>")
        sys.exit(1)

    origin_station = sys.argv[1]
    destination_station = sys.argv[2]

    paths_json = dijkstra(df, origin_station, destination_station)
    print(paths_json)